import type { MonthAvailability, DayAvailability } from "@/components/ui/month-availability-calendar";

export type SlotDraft = { start: string; end: string };

/**
 * Get active slots for a day (auto-generated minus excluded, plus custom)
 */
export function getActiveSlots(dayAvail: DayAvailability): Array<{ start: string; end: string; type: 'auto' | 'custom' }> {
  const slots: Array<{ start: string; end: string; type: 'auto' | 'custom' }> = [];
  
  // Add auto-generated slots (excluding excluded ones)
  if (dayAvail.autoGeneratedSlots) {
    dayAvail.autoGeneratedSlots.forEach(slot => {
      if (!dayAvail.excludedSlots?.includes(slot.start)) {
        slots.push({ ...slot, type: 'auto' });
      }
    });
  }
  
  // Add custom specific slots
  if (dayAvail.specificSlots) {
    for (let i = 0; i < dayAvail.specificSlots.length; i += 2) {
      const start = dayAvail.specificSlots[i];
      const end = dayAvail.specificSlots[i + 1];
      if (start && end) {
        slots.push({ start, end, type: 'custom' });
      }
    }
  }
  
  return slots.sort((a, b) => new Date(a.start).getTime() - new Date(b.start).getTime());
}

/**
 * Convert selected availability + enabled slots to SlotDraft array
 */
export function availabilityToSlots(
  selectedAvailability: MonthAvailability,
  enabledSlots: Record<string, Set<string>>,
  durationMinutes: number
): SlotDraft[] {
  const slots: SlotDraft[] = [];

  Object.entries(selectedAvailability).forEach(([dateStr, dayAvail]) => {
    if (!dayAvail.available) return;

    const enabledSlotsForDay = enabledSlots[dateStr] || new Set<string>();
    const activeSlots = getActiveSlots(dayAvail);

    // Only include slots that are enabled
    activeSlots.forEach(slot => {
      if (enabledSlotsForDay.has(slot.start)) {
        // Apply duration if needed (for auto-generated slots, duration is already applied)
        const slotStart = new Date(slot.start);
        const slotEnd = new Date(slot.end);
        
        // If slot duration doesn't match requested duration, adjust end time
        const currentDuration = (slotEnd.getTime() - slotStart.getTime()) / (1000 * 60);
        if (Math.abs(currentDuration - durationMinutes) > 1) {
          // Adjust end time to match requested duration
          slotEnd.setTime(slotStart.getTime() + durationMinutes * 60_000);
        }

        slots.push({
          start: slotStart.toISOString().slice(0, 16), // yyyy-mm-ddTHH:mm
          end: slotEnd.toISOString().slice(0, 16),
        });
      }
    });
  });

  return slots.sort((a, b) => new Date(a.start).getTime() - new Date(b.start).getTime());
}

/**
 * Convert existing slots back to availability format (for edit mode)
 * Merges with existing availability from settings to preserve slot structure
 */
export function slotsToAvailability(
  slots: SlotDraft[],
  existingAvailability?: MonthAvailability
): {
  availability: MonthAvailability;
  enabledSlots: Record<string, Set<string>>;
} {
  const availability: MonthAvailability = {};
  const enabledSlots: Record<string, Set<string>> = {};

  // Group slots by date
  const slotsByDate: Record<string, SlotDraft[]> = {};
  slots.forEach(slot => {
    if (!slot.start || !slot.end) return;
    const dateStr = new Date(slot.start).toISOString().slice(0, 10); // yyyy-mm-dd
    if (!slotsByDate[dateStr]) {
      slotsByDate[dateStr] = [];
    }
    slotsByDate[dateStr].push(slot);
  });

  // For each date with slots, merge with existing availability or create new
  Object.keys(slotsByDate).forEach(dateStr => {
    const dateSlots = slotsByDate[dateStr];
    const existingDay = existingAvailability?.[dateStr];
    
    if (existingDay && existingDay.available) {
      // Use existing availability structure
      availability[dateStr] = { ...existingDay };
      enabledSlots[dateStr] = new Set<string>();
      
      // Match slots to existing availability slots
      const activeSlots = getActiveSlots(existingDay);
      dateSlots.forEach(slot => {
        // Find matching slot in existing availability
        const matchingSlot = activeSlots.find(s => {
          const slotStart = new Date(slot.start);
          const existingStart = new Date(s.start);
          // Match if within 1 minute (to handle rounding)
          return Math.abs(slotStart.getTime() - existingStart.getTime()) < 60000;
        });
        
        if (matchingSlot) {
          enabledSlots[dateStr].add(matchingSlot.start);
        } else {
          // Slot doesn't match existing - add as custom slot
          if (!availability[dateStr].specificSlots) {
            availability[dateStr].specificSlots = [];
          }
          availability[dateStr].specificSlots!.push(slot.start, slot.end);
          enabledSlots[dateStr].add(slot.start);
        }
      });
    } else {
      // No existing availability for this date - create new structure
      availability[dateStr] = {
        date: dateStr,
        available: true,
        autoGeneratedSlots: [],
        excludedSlots: [],
        specificSlots: [],
      };
      enabledSlots[dateStr] = new Set<string>();
      
      // Add all slots as specific slots
      dateSlots.forEach(slot => {
        if (!availability[dateStr].specificSlots) {
          availability[dateStr].specificSlots = [];
        }
        availability[dateStr].specificSlots!.push(slot.start, slot.end);
        enabledSlots[dateStr].add(slot.start);
      });
    }
  });

  return { availability, enabledSlots };
}

